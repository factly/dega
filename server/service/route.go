package service

import (
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"

	"github.com/factly/dega-server/config"
	"github.com/factly/dega-server/util"
	"github.com/factly/x/healthx"

	_ "github.com/factly/dega-server/docs" // docs is generated by Swag CLI, you have to import it.
	"github.com/factly/dega-server/service/core"
	"github.com/factly/dega-server/service/core/action/author"
	"github.com/factly/dega-server/service/core/action/category"
	"github.com/factly/dega-server/service/core/action/format"
	"github.com/factly/dega-server/service/core/action/info"
	"github.com/factly/dega-server/service/core/action/meta"
	"github.com/factly/dega-server/service/core/action/post"
	"github.com/factly/dega-server/service/core/action/tag"
	factCheck "github.com/factly/dega-server/service/fact-check"
	"github.com/factly/dega-server/service/podcast"
	podcastAction "github.com/factly/dega-server/service/podcast/action"
	"github.com/factly/dega-server/service/reindex"
	"github.com/factly/dega-server/service/user"

	"github.com/factly/x/loggerx"
	"github.com/go-chi/chi"
	"github.com/go-chi/chi/middleware"
	"github.com/go-chi/cors"
	"github.com/spf13/viper"
	httpSwagger "github.com/swaggo/http-swagger"
)

func RegisterRoutes() http.Handler {
	r := chi.NewRouter()

	r.Use(middleware.RequestID)
	r.Use(loggerx.Init())
	r.Use(middleware.RealIP)
	r.Use(middleware.Recoverer)
	r.Use(middleware.Heartbeat("/ping"))

	if viper.IsSet("mode") && viper.GetString("mode") == "development" {
		r.Use(cors.Handler(cors.Options{
			AllowedOrigins:   []string{"http://localhost:3000"},
			AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
			AllowedHeaders:   []string{"*"},
			ExposedHeaders:   []string{"*"},
			AllowCredentials: true,
			MaxAge:           300, // Maximum value not ignored by any of major browsers
		}))
		r.Get("/swagger/*", httpSwagger.WrapHandler)
		fmt.Println("Swagger @ http://localhost:7789/swagger/index.html")
	}

	if viper.IsSet("iframely_url") {
		r.Mount("/meta", meta.Router())
	}

	sqlDB, _ := config.DB.DB()

	healthx.RegisterRoutes(r, healthx.ReadyCheckers{
		"database":    sqlDB.Ping,
		"meilisearch": util.MeiliChecker,
	})

	r.Get("/test/authorize", GetAuthorizationProxyHandler(viper.GetString("ZITADEL_ISSUER"), viper.GetString("ZITADEL_CLIENT_ID")))

	r.With(config.ZitadelInterceptor.RequireAuthorization(), util.CheckUser(config.ZitadelInterceptor)).Group(func(r chi.Router) {
		r.Mount("/core", core.Router())
		r.Mount("/fact-check", factCheck.Router())
		r.Mount("/podcast", podcast.Router())
		r.Mount("/reindex", reindex.Router())
	})

	r.With(config.ZitadelInterceptor.RequireAuthorization(), util.CheckUser(config.ZitadelInterceptor)).Group(func(r chi.Router) {
		r.Mount("/user", user.Router())
		r.Mount("/core/info", info.Router())
	})

	return r
}

func RegisterPublicRoutes() http.Handler {
	r := chi.NewRouter()

	r.Use(middleware.RequestID)
	r.Use(loggerx.Init())
	r.Use(middleware.RealIP)
	r.Use(middleware.Recoverer)
	r.Use(middleware.Heartbeat("/ping"))

	sqlDB, _ := config.DB.DB()

	healthx.RegisterRoutes(r, healthx.ReadyCheckers{
		"database":    sqlDB.Ping,
		"meilisearch": util.MeiliChecker,
	})

	if config.CacheEnabled() {
		config.SetupCache()
		r.Use(config.CachingMiddleware, config.RespMiddleware)
	}
	r.With(util.CheckAPIAcess).Group(func(r chi.Router) {
		r.Mount("/core", core.PublicRouter())
		r.Mount("/fact-check", factCheck.PublicRouter())
	})
	return r
}

func RegisterFeedsRoutes() http.Handler {
	r := chi.NewRouter()

	r.Use(middleware.RequestID)
	r.Use(loggerx.Init())
	r.Use(middleware.RealIP)
	r.Use(middleware.Recoverer)
	r.Use(middleware.Heartbeat("/ping"))

	r.Route("/spaces/{space_id}", func(r chi.Router) {
		r.Get("/posts/feed", post.Feeds)
		r.Get("/posts/feeds/rss2", post.Feeds)
		r.Get("/tags/{slugs}/feed", tag.Feeds)
		r.Get("/tags/{slugs}/feeds/rss2", tag.Feeds)
		r.Get("/categories/{slugs}/feed", category.Feeds)
		r.Get("/categories/{slugs}/feeds/rss2", category.Feeds)
		r.Get("/formats/{slugs}/feed", format.Feeds)
		r.Get("/formats/{slugs}/feeds/rss2", format.Feeds)
		r.Get("/authors/{slugs}/feed", author.Feeds)
		r.Get("/authors/{slugs}/feeds/rss2", author.Feeds)

		r.Get("/podcasts/{podcast_slug}/feed", podcastAction.Feeds)
		r.Get("/podcasts/{podcast_slug}/feeds/rss2", podcastAction.Feeds)
	})

	return r
}

func GetAuthorizationProxyHandler(zitadelIssuer string, svcUserID string) http.HandlerFunc {
	targetURL := zitadelIssuer + "/oauth/v2/authorize"
	return func(w http.ResponseWriter, r *http.Request) {
		proxyURL, err := buildProxyURL(r, targetURL)
		if err != nil {
			http.Error(w, "Failed to build proxy URL", http.StatusInternalServerError)
			return
		}
		resp, err := performProxyRequest("GET", proxyURL, nil, svcUserID)
		if err != nil {
			http.Error(w, "Failed to perform request", http.StatusInternalServerError)
			return
		}
		defer resp.Body.Close()
		handleAuthorizationResponse(w, r, resp)
	}
}

// buildProxyURL builds a proxy URL with query parameters.
func buildProxyURL(r *http.Request, targetURL string) (string, error) {
	params := url.Values{}
	for key, value := range r.URL.Query() {
		for _, v := range value {
			params.Add(key, v)
		}
	}
	return fmt.Sprintf("%s?%s", targetURL, params.Encode()), nil
}

// performProxyRequest performs an HTTP request to the proxy URL with optional headers.
func performProxyRequest(method, proxyURL string, body io.Reader, svcUserID string) (*http.Response, error) {
	req, err := http.NewRequest(method, proxyURL, body)
	if err != nil {
		return nil, err
	}
	if svcUserID != "" {
		req.Header.Set("X-Zitadel-Login-Client", svcUserID)
	}
	client := &http.Client{
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		},
	}
	return client.Do(req)
}

// handleAuthorizationResponse handles the response for the authorization request.
func handleAuthorizationResponse(w http.ResponseWriter, r *http.Request, resp *http.Response) {
	location := resp.Header.Get("Location")
	if location == "" {
		body, err := io.ReadAll(resp.Body)
		if err != nil {
			http.Error(w, "Failed to decode callback URL: "+err.Error(), http.StatusBadRequest)
			return
		}
		http.Error(w, "Failed to get location header: err: "+string(body), http.StatusInternalServerError)
		return
	}
	parsedURL, err := url.Parse(location)
	if err != nil {
		http.Error(w, "Failed to parse location URL: "+err.Error(), http.StatusInternalServerError)
		return
	}
	authRequestID := parsedURL.Query().Get("authRequest")
	if authRequestID == "" {
		http.Error(w, "authRequest parameter is required", http.StatusInternalServerError)
		return
	}

	log.Printf("Authorization request ID: %s", authRequestID)

	http.Redirect(w, r, location, http.StatusSeeOther)
}
